@PACKAGE_INIT@

# provide meta-data
set(@META_PROJECT_NAME@_varname "@META_PROJECT_VARNAME_UPPER@")
set(@META_TARGET_NAME@_varname "@META_PROJECT_VARNAME_UPPER@")
set(@META_PROJECT_VARNAME_UPPER@_DISPLAY_NAME "@META_APP_NAME@")
set(@META_PROJECT_VARNAME_UPPER@_AUTHOR "@META_APP_AUTHOR@")
set(@META_PROJECT_VARNAME_UPPER@_VERSION "@META_APP_VERSION@")
set(@META_PROJECT_VARNAME_UPPER@_VERSION_MAJOR "@META_VERSION_MAJOR@")
set(@META_PROJECT_VARNAME_UPPER@_VERSION_MINOR "@META_VERSION_MINOR@")
set(@META_PROJECT_VARNAME_UPPER@_VERSION_PATCH "@META_VERSION_PATCH@")
set(@META_PROJECT_VARNAME_UPPER@_GIT_REV_COUNT "@META_GIT_REV_COUNT@")
set(@META_PROJECT_VARNAME_UPPER@_GIT_LAST_COMMIT_ID "@META_GIT_LAST_COMMIT_ID@")
set(@META_PROJECT_VARNAME_UPPER@_URL "@META_APP_URL@")
set(@META_PROJECT_VARNAME_UPPER@_DESCRIPTION "@META_APP_DESCRIPTION@")
set(@META_PROJECT_VARNAME_UPPER@_LICENSE "@META_PROJECT_LICENSE@")

# define general config
set(@META_PROJECT_VARNAME_UPPER@_IS_HEADER_ONLY @META_HEADER_ONLY_LIB@)
set(@META_PROJECT_VARNAME_UPPER@_INCLUDE_DIRS "@PACKAGE_HEADER_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_BIN_DIR "@PACKAGE_BIN_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_LIB_DIR "@PACKAGE_LIB_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_MODULE_DIRS "@PACKAGE_CMAKE_MODULE_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_CONFIG_DIRS "@PACKAGE_CMAKE_CONFIG_INSTALL_DESTINATION@")
set(@META_PROJECT_VARNAME_UPPER@_PRIVATE_QT_MODULES "@QT_MODULES@")
set(@META_PROJECT_VARNAME_UPPER@_PRIVATE_KF_MODULES "@KF_MODULES@")
set(@META_PROJECT_VARNAME_UPPER@_PUBLIC_QT_MODULES "@META_PUBLIC_QT_MODULES@")
set(@META_PROJECT_VARNAME_UPPER@_PUBLIC_KF_MODULES "@META_PUBLIC_KF_MODULES@")
set(@META_PROJECT_VARNAME_UPPER@_REQUIRED_PACKAGES "@INTERFACE_REQUIRED_PACKAGES@")
set(@META_PROJECT_VARNAME_UPPER@_REQUIRED_PKG_CONFIG_MODULES "@INTERFACE_REQUIRED_PKG_CONFIG_MODULES@")
set(@META_PROJECT_VARNAME_UPPER@_HAS_QT_TRANSLATION_FILES @APP_SPECIFIC_QT_TRANSLATIONS_AVAILABLE@)
set(@META_PROJECT_VARNAME_UPPER@_QT_RESOURCES @QT_RESOURCES@)

# define mapping from CMake targets to pkg-config module names
@TARGET_TO_PKG_CONFIG_MODULE_NAME_MAPPING@

# define additional find_package arguments for required CMake-packages
@ADDITIONAL_ARGUMENTS_FOR_REQUIRED_CMAKE_PACKAGES@
# define library config, add imported target
set(@META_PROJECT_VARNAME_UPPER@_PACKAGE "@META_PROJECT_NAME@@META_CONFIG_SUFFIX@")
set(@META_PROJECT_VARNAME_UPPER@_LIB "@META_TARGET_NAME@")
set(@META_PROJECT_VARNAME_UPPER@_LIB_IS_SHARED "@BUILD_SHARED_LIBS@")
set(@META_PROJECT_VARNAME_UPPER@_STATIC_LINKAGE "@STATIC_LINKAGE_CONFIGURED@")
if(NOT TARGET "${@META_PROJECT_VARNAME_UPPER@_LIB}")
    # add target for the library itself
    include("${CMAKE_CURRENT_LIST_DIR}/@META_PROJECT_NAME@@META_CONFIG_SUFFIX@Targets.cmake")

    # make dependencies of the library available
    # caveat: This currently does *not* cover Qt and KF modules which are so far only handled
    #         separately when using the function use_@META_PROJECT_VARNAME@.

    # prefer static libraries if @META_PROJECT_NAME@ was configured this way during its build
    if (@META_PROJECT_VARNAME_UPPER@_STATIC_LINKAGE)
        set(@META_PROJECT_VARNAME_UPPER@_DEFAULT_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
        if (WIN32)
            set(CMAKE_FIND_LIBRARY_SUFFIXES .a .lib)
        else ()
            set(CMAKE_FIND_LIBRARY_SUFFIXES .a)
        endif ()
        set(@META_PROJECT_VARNAME_UPPER@_DEFAULT_PKG_CONFIG_USE_STATIC_LIBS ${PKG_CONFIG_USE_STATIC_LIBS})
        set(PKG_CONFIG_USE_STATIC_LIBS ON)
    endif ()

    # find all required packages
    foreach (_REQUIRED_PACKAGE ${@META_PROJECT_VARNAME_UPPER@_REQUIRED_PACKAGES})
        string(REGEX MATCH _REQUIRED_PACKAGE_MATCH "(.*)-([^-]*)" "${_REQUIRED_PACKAGE}")
        if (_REQUIRED_PACKAGE_MATCH)
            set(_REQUIRED_PACKAGE "${CMAKE_MATCH_1}")
            set(_REQUIRED_VERSION "${CMAKE_MATCH_2}")
        else ()
            unset(_REQUIRED_VERSION)
        endif ()
        string(REPLACE "::" "_" _REQUIRED_PACKAGE_VARNAME "${_REQUIRED_PACKAGE}")
        if (@META_PROJECT_VARNAME_UPPER@_FIND_PACKAGE_ARGS_${_REQUIRED_PACKAGE_VARNAME})
            set(_FIND_PACKAGE_ARGS ${@META_PROJECT_VARNAME_UPPER@_FIND_PACKAGE_ARGS_${_REQUIRED_PACKAGE_VARNAME}})
        else ()
            set(_FIND_PACKAGE_ARGS REQUIRED)
        endif ()
        if (_REQUIRED_VERSION)
            find_package("${_REQUIRED_PACKAGE}" "${_REQUIRED_VERSION}" ${_FIND_PACKAGE_ARGS})
        else ()
            find_package("${_REQUIRED_PACKAGE}" ${_FIND_PACKAGE_ARGS})
        endif()
    endforeach()

    # find all required pkg-config modules
    if (@META_PROJECT_VARNAME_UPPER@_REQUIRED_PKG_CONFIG_MODULES)
        include(3rdParty)
        foreach (@META_PROJECT_VARNAME_UPPER@_REQUIRED_PKG_CONFIG_MODULE ${@META_PROJECT_VARNAME_UPPER@_REQUIRED_PKG_CONFIG_MODULES})
            string(REPLACE "::" "_" @META_PROJECT_VARNAME_UPPER@_REQUIRED_PKG_CONFIG_MODULE_VARNAME "${@META_PROJECT_VARNAME_UPPER@_REQUIRED_PKG_CONFIG_MODULE}")
            use_pkg_config_module(
                TARGET_NAME "${@META_PROJECT_VARNAME_UPPER@_REQUIRED_PKG_CONFIG_MODULE}"
                PKG_CONFIG_MODULES "${PKG_CONFIG_${@META_PROJECT_VARNAME_UPPER@_REQUIRED_PKG_CONFIG_MODULE_VARNAME}}"
                LIBRARIES_VARIABLE DEV_NULL
                PKG_CONFIG_MODULES_VARIABLE DEV_NULL
            )
        endforeach ()
    endif ()

    # restore preference of static libraries
    if (@META_PROJECT_VARNAME_UPPER@_STATIC_LINKAGE)
        set(CMAKE_FIND_LIBRARY_SUFFIXES ${@META_PROJECT_VARNAME_UPPER@_DEFAULT_CMAKE_FIND_LIBRARY_SUFFIXES})
        unset(@META_PROJECT_VARNAME_UPPER@_DEFAULT_CMAKE_FIND_LIBRARY_SUFFIXES)
        set(PKG_CONFIG_USE_STATIC_LIBS ${@META_PROJECT_VARNAME_UPPER@_DEFAULT_PKG_CONFIG_USE_STATIC_LIBS})
        unset(@META_PROJECT_VARNAME_UPPER@_DEFAULT_PKG_CONFIG_USE_STATIC_LIBS)
    endif ()
endif()

# define function to ease use of library in projects following conventions of c++utilities' build script
function(use_@META_PROJECT_VARNAME@)
    # make CMake modules of the project available
    list(APPEND CMAKE_MODULE_PATH "${@META_PROJECT_VARNAME_UPPER@_MODULE_DIRS}")
    set(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH}" PARENT_SCOPE)

    # parse arguments
    include(3rdParty)
    parse_arguments_for_use_functions(${ARGN})

    # link against library (also "link" against header-only libs to get compile defs and interface link libs)
    link_directories(${@META_PROJECT_VARNAME_UPPER@_LIB_DIR})
    if (ARGS_ONLY_HEADERS)
        set(TARGET_NAME "${@META_PROJECT_VARNAME_UPPER@_LIB}-headers")
    else ()
        set(TARGET_NAME "${@META_PROJECT_VARNAME_UPPER@_LIB}")
    endif ()
    set("${ARGS_LIBRARIES_VARIABLE}" "${${ARGS_LIBRARIES_VARIABLE}};${TARGET_NAME}" PARENT_SCOPE)
    set("${ARGS_PACKAGES_VARIABLE}" "${${ARGS_PACKAGES_VARIABLE}};${@META_PROJECT_VARNAME_UPPER@_PACKAGE}" PARENT_SCOPE)

    if (ARGS_ONLY_HEADERS)
        return ()
    endif ()

    # add required Qt and KF modules
    set(IMPORTED_QT_MODULES
        ${IMPORTED_QT_MODULES}
        ${@META_PROJECT_VARNAME_UPPER@_PUBLIC_QT_MODULES}
        ${@META_PROJECT_VARNAME_UPPER@_PRIVATE_QT_MODULES}
        PARENT_SCOPE
    )
    set(IMPORTED_KF_MODULES
        ${IMPORTED_KF_MODULES}
        ${@META_PROJECT_VARNAME_UPPER@_PUBLIC_KF_MODULES}
        ${@META_PROJECT_VARNAME_UPPER@_PRIVATE_KF_MODULES}
        PARENT_SCOPE
    )

    # add required translations to APP_SPECIFIC_QT_TRANSLATION_FILES_ARRAY
    if(@META_PROJECT_VARNAME_UPPER@_HAS_QT_TRANSLATION_FILES)
        set(APP_SPECIFIC_QT_TRANSLATION_FILES "${APP_SPECIFIC_QT_TRANSLATION_FILES};@META_PROJECT_NAME@" PARENT_SCOPE)
    endif()

    # add Qt resources if it is a static library
    if (NOT @META_PROJECT_VARNAME_UPPER@_LIB_IS_SHARED)
        set(STATIC_LIBRARIES_QT_RESOURCES "${STATIC_LIBRARIES_QT_RESOURCES};${@META_PROJECT_VARNAME_UPPER@_QT_RESOURCES}" PARENT_SCOPE)
    endif()
endfunction()
